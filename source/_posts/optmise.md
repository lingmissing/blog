title: 前端性能优化篇
date: 2018-06-22 13:25:49
tags: [css,javascript]
categories: 前端性能优化
---
# 根据渲染过程
由于页面是自上而下的加载，详情请参考https://segmentfault.com/a/1190000010298038, 因此可如下优化：
* 减少dom层次
* 将css放在顶部，js放在底部
* js可采用异步加载（defer、async）
# 减少HTTP请求
* CSS/JS 合并打包
* 小图标等用iconfont代替
* 使用base64格式的图片
# 减少静态资源的体积
* 压缩静态资源
* 编写高效率的CSS（不要嵌套太多）
* 服务端开启gzip压缩（服务端）
* 路由按需加载
<!-- more -->
# 使用缓存
浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：
1. 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
2. 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
* 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；
* 区别是，强缓存不对发送请求到服务器，但协商缓存会。
* 当协商缓存也没命中时，服务器就会将资源发送回客户端。
* 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
* 当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；
**强缓存**
* Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）
* Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）
**协商缓存**
* Last-Modified（值为资源最后更新时间，随服务器response返回）
* If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
* ETag（表示资源内容的唯一标识，随服务器response返回）
* If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）
# 其他优化
* 函数节流，函数防抖
* requestAnimationFrame在下一帧开始前调用函数。优于setInterval的地方是每一帧只会调用一次
* CSS的will-change和 transform: translateZ(0)可以用来创建新layer
* 使用cdn
* 图片懒加载
* 避免图片 src 为空